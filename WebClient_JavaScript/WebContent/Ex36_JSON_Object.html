<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
<script type="text/javascript">
	/*

​

자바 설계도(클래스) => 재사용성

class Product{
	private String carname="pony";
	
	public Product(){}
	public Product(String carname){
		this.carname= carname;

}

public void print(){

	System.out.println(this.carname);

}

}

​

메모리 load ... (new)

Product p = new Product();
Product p2 = new Product("pony2");

​

p.print();
p2.print();
/////////////////////////////////////////////////////

​

javaScript >> 객체지향언어(OOP)

​

클래스 정의 3가지 방법

1. 프로토타입 방식 : 일반적인 클래스 제작 방법
인스턴스마다 공통된 메서드를 공유해서 사용하는 장점 

Jquery 도 prototype 방식으로 설계

​

function 클래스이름() {

this.프로퍼티1 = 초기값;
this.프로퍼티2 = 초기값;

}

​

클래스이름.prototype.메서드1 = function() {

}

클래스이름.prototype.메서드2 = function() {

}

var 인스턴스 = new 클래스이름(); 

var carObj = new Car();
var carObj2 = new Car();
var carObj3 = new Car();

​

​

2. 함수 방식 : 간단한 클래스 제작 시 사용 

인스턴스마다 메서드가 독립적으로 만들어지는 단점

** 클래스 : function Car(){ this.name = , this.age=}
** 함수 : function car(){}

function 클래스이름() {
	this.프로퍼티1 = 초기값;
	this.프로퍼티2 = 초기값;
​

this.메서드1 = function() {

}

this.메서드2 = function() {

}

}

var 인스턴스 = new 클래스이름(); 

var carObj = new Car();
var carObj2 = new Car();
var carObj3 = new Car();

​

​

​
**************************************************
3. 리터럴 방식 : 클래스 만드는 용도는 아니며 주로 여러개의 매개변수를 그룹으로 묶어 함수의 매개변수로 보낼때
              정의와 함께 인스턴스가 만들어지는 장점이 있음 단 인스턴스는 오직 하나 (초보자에게도 중요 ^^)

4. ECMA6 버전부터 : class 키워드 제공

		class Person {
			constructor(name) {
			this._name = name;
			}
			sayHi() {
						console.log(`Hi! ${this._name}`);
					}
	}

[ javascript 객체 생성 ]

1.오브젝트 리터럴 방식 (객체를 만드는 방법): 클래스 생성과 동시에 객체가 만들어 져요

1.1 리터럴 방식(=JSON방식) >> 제일 간단한 방법 > var obj = {}; //var objarr = [] 배열 
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!자바스크립트에서 배열을 만들때는 [] 대괄호 / 자바스크립트에서 객체를 만들때는 {} 중괄호!!!!!!!!!!!!!!!!!!!!!!!!!!
1.2 JSON 표기 : {} >> JSON: JavaScript Object Notation

​

ex) var myObj = { "name":"John", "age":31, "city":"New York" };
			자바에서 String name = John 과 같은거임(:)
TIP) JSON >> XML (텍스트 기반의 형식화된 문서 제공)

XML :이기종간의 데이터 호환 (한 때는 서점 : xml webservice)

​

다른 이야기 >> JSON

객체지향언어 장점 : 설계도 (재사용성)

	*오브젝트 리터럴 방식 : 재사용을 지원하는 않는다 

	*설계도를 생성과 동시에 객체 생성(장점 : 편하고 , 빠르다 )

	*설계도를 미리 만들어 놓고 재사용하는 방식은 아니다

	*설계도당 하나의 객체만 생성 사용 (only object)


	var product = {};		//자바로 치면 Product p = new Product();와 같은거임

	var product2 = {제품명:'사과',년도:'2018',원산지:'대구'};

	var 인스턴스 ={

		프로퍼티:초기값,
		프로퍼티:초기값,
		.....
		메서드:function(){},
		메서드:function(){}....
	}

​

	리터럴 방식 > 선언과 동시에 인스턴스 자동 생성
	var 인스턴스 = {}
	특징 : 생성자 존재하지 않는다.
	프로퍼티와 메서드만 정의 가능
	단점 : 객체 하나 생성(재사용성 없다) 
	접근방법 : 인스턴스이름.자원 >> product2.제품명 
*/	
	
	//굳이 자바랑 비교하자면
	//class Product {private String 제품명 = "사과"  ....}
	//Product product = new Product();
	let product = {제품명 : '사과', 년도:'2000',원산지:'대구'}; //이게 value값
	console.log(product); //proto타입(=부모타입) -> object
	
	document.write(product.제품명 + "<br>");
	document.write(product.년도 + "<br>");
	document.write(product.원산지 + "<br>");
	document.write(product.toString() + "<br>");
	
	//{객체}
	let person = {name : "홍길동", 
				  addr : "서울시 강남구 역삼동",
				  eat  : function(food){
					  document.write(this.name + "/" + this.addr + "/" + food + "냠냠"); //this를 사용한다!(this를 통해서 person객체의 것임을 알려준다)
				  	}
				};
	
	document.write("<hr>");
	person.eat("사과");	//함수 호출
	
	//1. 속성 제거 기능
	//product = {제품명 : '사과', 년도:'2000',원산지:'대구'}
	//Map 비슷
	delete(product.년도);
	console.log(product);
	
	//for(let index in Array){} //개선된 for문에서 배열을 쓰면 return되는건 index(첨자값)
	//for(let key in product){} //개선된 for문에서 객체를 쓰면 return되는건 key -> 그래서 value값을 얻을수 있다.
	
	for(let key in product){	//원래 in뒤에는 배열이 왔는데, 객체를 줄수도 있대(product)
		console.log("key : " + key);
		console.log(product[key]);
	}
	
	for(let key in person){
		console.log(("key : " + key + "=" + person[key]));
	}
	//json 객체 활용 (xml)
	//외부 API 제공 (제공 데이터 : xml or json : 서울시 공공데이터, 대법원 판례, 날씨 정보)
	//KEY POINT : 제공 받은 xml or json 객체를 원하는 데이터만 추출해서 화면 출력
	//2차 프로젝트 강제사항 최소 2개 이상 (외부 API) >>  차트
	
	let Member={}; //빈 객체
	Member.name = "hong"; //{name : "hong"} 속성 추가 (setter getter인거임)
	console.log(Member);
	console.log(Member.name);
	
	Member.age = 100;
	
	//기능(함수)
	Member.print = function(){
		document.write("<br>" + this.name + "/" + this.age + "<br>");
	}
	Member.print();
	//POINT 객체가 객체를 가질수 있다, 객체가 배열을 가질 수 있다
	//java : class Member {Car car; ArrayList list;}
	
	let Grade = {
			"list" : {
					"hong" : 10,
					"kim" : 20,
					"park" : 30
			},
			"show" : function(){
				for(let key in this.list)
					document.write(key + ":" + this.list[key] + "<br>");
			}
	}
	Grade.show();
	document.write("<hr>");
	
	let listobj = Grade.list; //Grade라는 객체가 가지고 있는 list프로퍼티의 주소값
	document.write(listobj.kim);
	document.write("<br>");
	
	for(let key in listobj){
		document.write(key + ":" + listobj[key] + "<br>");
	}
	
	</script>
</head>
<body>

</body>
</html>














